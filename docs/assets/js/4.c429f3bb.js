(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{358:function(t,e,r){t.exports=r.p+"assets/img/widget.8a01ecde.png"},359:function(t,e,r){t.exports=r.p+"assets/img/flutter_render.92a1d12d.png"},360:function(t,e,r){t.exports=r.p+"assets/img/flutter_state.c6a2cef7.png"},361:function(t,e,r){t.exports=r.p+"assets/img/flutter_GPU.9fd206d0.png"},389:function(t,e,r){"use strict";r.r(e);var a=r(42),i=Object(a.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"flutter"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flutter"}},[t._v("#")]),t._v(" flutter")]),t._v(" "),a("h3",{attrs:{id:"flutter-简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flutter-简介"}},[t._v("#")]),t._v(" Flutter 简介")]),t._v(" "),a("blockquote",[a("p",[t._v("Flutter是Google的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。")])]),t._v(" "),a("p",[t._v("Flutter使用自绘UI+原生实现（使用自己的Skia引擎来绘 制 widget）。")]),t._v(" "),a("ul",[a("li",[t._v("Flutter借鉴的是React思想，页面使用Widget搭建\n"),a("ul",[a("li",[t._v("Widget就相当于一个UI库")])])])]),t._v(" "),a("p",[t._v("Flutter中有四⼤线程，Platform Task Runner 、UI Task Runner、GPU Task Runner 和 IO Task Runner。运行机制和JS类似。")]),t._v(" "),a("p",[t._v("对于 Flutter ⽽⾔，整个屏幕都是⼀块画布，我们通过各种 Offset 和 Rect 确定了位置，然后通过 PaintingContext 的 Canvas 绘制上去，⽬标是整个屏幕区域，整个屏幕就是⼀帧，每次改变都是重新绘制。")]),t._v(" "),a("h3",{attrs:{id:"优势："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优势："}},[t._v("#")]),t._v(" 优势：")]),t._v(" "),a("ul",[a("li",[t._v("对外提供了完全不依赖系统平台的 Widget 的能力")]),t._v(" "),a("li",[t._v("只通过自绘图形的方式工作（Skia），而 Android 自带 Skia")]),t._v(" "),a("li",[t._v("因此具有极其优秀的跨平台性（iOS和Android的效果基本完全一致）")]),t._v(" "),a("li",[t._v("目前已经支持了 iOS、Android、Fuchsia")]),t._v(" "),a("li",[t._v("Dart支持JIT和AOT")]),t._v(" "),a("li",[t._v("支持热重载")]),t._v(" "),a("li",[t._v("应用程序速度快。")])]),t._v(" "),a("h3",{attrs:{id:"环境搭建"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#环境搭建"}},[t._v("#")]),t._v(" 环境搭建")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://flutter.dev/",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://flutter.dev/"),a("OutboundLink")],1)]),t._v(" "),a("h3",{attrs:{id:"widget"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#widget"}},[t._v("#")]),t._v(" Widget")]),t._v(" "),a("p",[t._v("在 Flutter 中，⼀切的显示都是 Widget 。Widget 是通过 state 跨帧实现管理数据状态的，（类似于React）")]),t._v(" "),a("p",[t._v("渲染经历了从 Widget 到 Element 再到 RenderObject 的过程。")]),t._v(" "),a("p",[t._v("Flutter 中的根Widget 是"),a("code",[t._v("RenderObjectToWidgetAdapter")]),t._v(",根 Widget 的 child 就是我们在void runApp(Widget app)中传入的自定义 Widget。")]),t._v(" "),a("div",{attrs:{align:"center"}},[a("p",[a("img",{attrs:{src:r(358),alt:"widget"}})])]),t._v(" "),a("p",[t._v("Widget 分为 有状态（"),a("code",[t._v("StatefulWidget")]),t._v("）和 ⽆状态（"),a("code",[t._v("StatelessWidget")]),t._v("）两种，在 Flutter 中每个⻚⾯都是⼀帧，⽆状态就是保持在那⼀帧，⽽有状态的 Widget 当数据更新时，其实是绘制了新的 Widget，只是 State 实现了跨帧的数据同步保存。")]),t._v(" "),a("p",[t._v("State 中主要的生命周期：")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("initState")]),t._v(" ：初始化，理论上只有初始化⼀次，第⼆篇中会说特殊情况下。")]),t._v(" "),a("li",[a("code",[t._v("didChangeDependencies")]),t._v("：在 initState 之后调⽤，此时可以获取其他 State 。")]),t._v(" "),a("li",[a("code",[t._v("dispose")]),t._v(" ：销毁，只会调⽤⼀次。*")])]),t._v(" "),a("p",[t._v("在Flutter中，要主动改变⼦控件的状态，还可以使⽤ "),a("code",[t._v("GlobalKey")]),t._v(" 。")]),t._v(" "),a("p",[t._v("具体每个Widget的使用方式和展现："),a("a",{attrs:{href:"https://github.com/zhongmeizhi/flutter-UI",target:"_blank",rel:"noopener noreferrer"}},[t._v("Flutter-UI"),a("OutboundLink")],1)]),t._v(" "),a("h1",{attrs:{id:"flutter-实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flutter-实现原理"}},[t._v("#")]),t._v(" Flutter 实现原理")]),t._v(" "),a("p",[t._v("渲染\n"),a("img",{attrs:{src:r(359),alt:"渲染"}})]),t._v(" "),a("p",[t._v("状态\n"),a("img",{attrs:{src:r(360),alt:"状态"}})]),t._v(" "),a("p",[t._v("GPU\n"),a("img",{attrs:{src:r(361),alt:"GPU"}})])])}),[],!1,null,null,null);e.default=i.exports}}]);