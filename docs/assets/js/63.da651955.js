(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{429:function(e,o,t){"use strict";t.r(o);var v=t(42),r=Object(v.a)({},(function(){var e=this,o=e.$createElement,t=e._self._c||o;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"promise"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[e._v("#")]),e._v(" Promise")]),e._v(" "),t("blockquote",[t("p",[e._v("Promise 是一个对象，它代表了一个异步操作的最终完成或者失败。")])]),e._v(" "),t("h3",{attrs:{id:"promise-概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-概念"}},[e._v("#")]),e._v(" Promise 概念")]),e._v(" "),t("p",[e._v("一个 Promise有以下几种状态:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("pending")]),e._v(": 初始状态，既不是成功，也不是失败状态。")]),e._v(" "),t("li",[t("code",[e._v("fulfilled")]),e._v(": 意味着操作成功完成。")]),e._v(" "),t("li",[t("code",[e._v("rejected")]),e._v(": 意味着操作失败。")])]),e._v(" "),t("p",[e._v("不同于“老式”的传入回调，在使用 Promise 时，会有以下约定：")]),e._v(" "),t("ul",[t("li",[e._v("在 本轮 "),t("code",[e._v("Javascript event loop")]),e._v("（事件循环）运行完成 之前，回调函数是不会被调用。")]),e._v(" "),t("li",[e._v("通过 "),t("code",[e._v("then()")]),e._v(" 添加的回调函数总会被调用，即便它是在异步操作完成之后才被添加的函数。")]),e._v(" "),t("li",[e._v("通过多次调用 "),t("code",[e._v("then()")]),e._v("，可以添加多个回调函数，它们会按照插入顺序一个接一个独立执行。")])]),e._v(" "),t("p",[e._v("因为 Promise.prototype.then 和  Promise.prototype.catch 方法返回promise 对象， 所以它们可以被链式调用。")]),e._v(" "),t("p",[e._v("Promise的 4 个方法")]),e._v(" "),t("ol",[t("li",[e._v("Promise.all(iterable)")]),e._v(" "),t("li",[e._v("Promise.race(iterable)")]),e._v(" "),t("li",[e._v("Promise.resolve(value)")]),e._v(" "),t("li",[e._v("Promise.reject(reason)")])]),e._v(" "),t("p",[e._v("Promise的 prototype")]),e._v(" "),t("ol",[t("li",[e._v("Promise.prototype.catch(onRejected)")]),e._v(" "),t("li",[e._v("Promise.prototype.then(onFulfilled, onRejected)")]),e._v(" "),t("li",[e._v("Promise.prototype.finally(onFinally)")])])])}),[],!1,null,null,null);o.default=r.exports}}]);