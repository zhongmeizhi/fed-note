(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{348:function(t,s,v){t.exports=v.p+"assets/img/stack.05aea686.png"},378:function(t,s,v){"use strict";v.r(s);var a=v(42),_=Object(a.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"js-执行上下文"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js-执行上下文"}},[t._v("#")]),t._v(" JS 执行上下文")]),t._v(" "),a("ol",[a("li",[t._v("宿主(浏览器和node)和v8的关系\n"),a("ol",[a("li",[t._v("node和浏览器事件循环系统不一致")]),t._v(" "),a("li",[t._v("dom操作会很慢？")])])]),t._v(" "),a("li",[t._v("v8的执行过程 编译 执行 热代码")]),t._v(" "),a("li",[t._v("声明、 if、严格模式\n"),a("ol",[a("li",[t._v("为什么会有变量提升？\n"),a("ol",[a("li",[t._v("因为js代码解析的结果会放到内存中")]),t._v(" "),a("li",[t._v("所以v8的js代码采用惰性解析")])])]),t._v(" "),a("li",[t._v("为什么let和const有暂时性的死区？\n"),a("ol",[a("li",[t._v("在预解析阶段并没有提前声明")]),t._v(" "),a("li",[t._v("let、const存放在上下文的词法环境中\n"),a("ol",[a("li",[t._v("由于该变量在词法环境中，所以可以做成块级作用域")])])])])])])]),t._v(" "),a("li",[t._v("堆栈结构、执行上下文，执行上下文的垃圾回收\n"),a("ol",[a("li",[t._v("为什么采用堆栈结构？\n"),a("ol",[a("li",[t._v("方便移交控制权")])])]),t._v(" "),a("li",[t._v("执行上下文不同ES版本会不一样")]),t._v(" "),a("li",[t._v("堆栈结构的栈溢出和异常提示")]),t._v(" "),a("li",[t._v("解决栈溢出问题，协程和尾递归（部分没有）")]),t._v(" "),a("li",[t._v("调用栈的垃圾回收\n"),a("ol",[a("li",[t._v("esp寄存器保存栈顶指针")]),t._v(" "),a("li",[t._v("当调用栈执行完成后，挪动栈顶指针，")]),t._v(" "),a("li",[t._v("下一次入栈时从指针开始进行覆盖")])])])])]),t._v(" "),a("li",[t._v("变量环境和作用域链寻址")]),t._v(" "),a("li",[t._v("块状结构、词法环境")]),t._v(" "),a("li",[t._v("堆内存和栈内存\n"),a("ol",[a("li",[t._v("栈内存的好处（快）是线性结构的连续空间，堆内存（慢）是非连续空间")]),t._v(" "),a("li",[t._v("同理，计算机中有cpu的寄存器，内存，硬盘都可以存放数据，而硬盘存放的量最大，为什么不把数据都放到硬盘中？")])])]),t._v(" "),a("li",[t._v("对象的字典结构和链式结构，快属性和慢属性")]),t._v(" "),a("li",[t._v("unshift 和 push")]),t._v(" "),a("li",[t._v("函数和为什么基于原形而不是基于类")]),t._v(" "),a("li",[t._v("闭包 colsure，编译阶段，垃圾回收")]),t._v(" "),a("li",[t._v("自执行函数anonymous 和（小括号）")])]),t._v(" "),a("p",[t._v("全局执行上下文在 V8 的生存周期内是不会被销毁")]),t._v(" "),a("h2",{attrs:{id:"为什么会出现变量提升？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么会出现变量提升？"}},[t._v("#")]),t._v(" 为什么会出现变量提升？")]),t._v(" "),a("p",[t._v("讲变量提升之前先介绍下编程语言的有2种编译方式："),a("code",[t._v("JIT")]),t._v(" 和 "),a("code",[t._v("AOT")]),t._v("。")]),t._v(" "),a("ul",[a("li",[t._v("AOT (Ahead-Of-Time - 预先编译)\n"),a("ul",[a("li",[t._v("编译步骤：词法分析 -> 语法分析 -> 语义检查 -> 代码优化和字节码生成")])])]),t._v(" "),a("li",[t._v("JIT（Just-In-Time - 实时编译）\n"),a("ul",[a("li",[t._v("编译步骤：词法分析 -> 语法分析 -> 语法树 -> 解释执行")])])])]),t._v(" "),a("p",[t._v("ps：具体js的语法分析结果可以查看："),a("a",{attrs:{href:"https://esprima.org/demo/parse.html#",target:"_blank",rel:"noopener noreferrer"}},[t._v("JS语法分析成语法树"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("每种编译方式都有各自的优缺点，这里以js为例，js属于jit编译，这样的好处是可以做到动态的代码生成，也不会出现在引入js文件时出现长时间的编译操作。")]),t._v(" "),a("h3",{attrs:{id:"js解释执行"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js解释执行"}},[t._v("#")]),t._v(" js解释执行")]),t._v(" "),a("p",[t._v("js解释执行严格按照js作用域链（scope chain）机制执行的，")]),t._v(" "),a("h3",{attrs:{id:"调用栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#调用栈"}},[t._v("#")]),t._v(" 调用栈")]),t._v(" "),a("p",[t._v("栈也是一种数据结构，它是一种运算受限的线性表，限定在表尾进行插入和删除。向栈顶插入元素叫"),a("code",[t._v("入栈")]),t._v("，从栈顶删除元素叫"),a("code",[t._v("出栈")])]),t._v(" "),a("p",[t._v("而调用栈是计算机科学中存储有关正在运行的子程序的消息的栈，几乎所有计算机程序都依赖于调用栈。调用栈的主要功能是"),a("strong",[t._v("存放返回地址")])]),t._v(" "),a("p",[t._v("举一个递归调用栈的栗子")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("fact")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("x")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("fact")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("使用一个图解算法中的案例：（灵魂画手正在路上）")]),t._v(" "),a("p",[a("img",{attrs:{src:v(348),alt:"stack"}})]),t._v(" "),a("p",[t._v("注意：调用栈中每个函数都有自己的变量：")]),t._v(" "),a("p",[t._v("既然说到了调用栈，这里就再举一反三谈谈js的作用域。")]),t._v(" "),a("p",[t._v("调用栈的用处：")]),t._v(" "),a("ol",[a("li",[t._v("异常捕获：由于是堆栈的形式，当一个函数出错时很方便的可以追溯到调用它的函数和一些其他出错信息。")])])])}),[],!1,null,null,null);s.default=_.exports}}]);