(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{382:function(a,e,t){"use strict";t.r(e);var s=t(42),n=Object(s.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"dart-稍微抽象点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dart-稍微抽象点"}},[a._v("#")]),a._v(" Dart-稍微抽象点")]),a._v(" "),t("h3",{attrs:{id:"泛型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#泛型"}},[a._v("#")]),a._v(" 泛型")]),a._v(" "),t("p",[a._v("泛型：有些情况下你可能想使用类型来表明你的意图，不管是使用泛型还是 具体类型。")]),a._v(" "),t("p",[a._v("在 Dart 中类型是可选的，你可以选择不用泛型。类、函数/方法中都可以使用泛型。")]),a._v(" "),t("p",[a._v("泛型通过 "),t("code",[a._v("<类型>")]),a._v("来使用。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("  // 通过泛型就可以减少包含具体类型定义的重复代码\n  abstract class Cache<T> {\n    T getByKey(String key);\n    setByKey(String key, T value);\n  }\n\n  // 泛型还能 限制泛型类型\n  class Foo<T extends SomeBaseClass> {...}\n\n  // 可以在函数/方法中使用泛型\n  T first<T>(List<T> ts) {\n    T tmp ?= ts[0];\n    return tmp;\n  }\n")])])]),t("p",[a._v("这里的 first ("),t("T",[a._v(") 泛型可以在如下地方使用 参数 T ：")])],1),a._v(" "),t("ul",[t("li",[a._v("函数的返回值类型 (T).")]),a._v(" "),t("li",[a._v("参数的类型 (List"),t("T",[a._v(").")])],1),a._v(" "),t("li",[a._v("局部变量的类型 (T tmp).")])]),a._v(" "),t("h3",{attrs:{id:"导入"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#导入"}},[a._v("#")]),a._v(" 导入")]),a._v(" "),t("p",[a._v("普通导入")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("  import 'dart:io';\n  import 'package:lib1/lib1.dart';\n")])])]),t("p",[a._v("指定库前缀 （如果你导入的两个库具有冲突的标识符）")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("  import 'package:lib1/lib1.dart';\n  import 'package:lib2/lib2.dart' as lib2;\n  \n  Element element1 = new Element();           // 使用lib1.\n  lib2.Element element2 = new lib2.Element(); // 使用lib2.\n")])])]),t("p",[a._v("部分导入")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("  // 只导入 foo\n  import 'package:lib1/lib1.dart' show foo;\n\n  // 导入 liab2 但排除 foo\n  import 'package:lib2/lib2.dart' hide foo;\n")])])]),t("p",[a._v("延迟载入库（）")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("  // 延迟导入库\n  import 'package:deferred/hello.dart' deferred as hello;\n\n  // 使用库\n  greet() async {\n\n    // 库标识符调用 loadLibrary() 函数来加载库：\n    // loadLibrary 返回 Future\n    await hello.loadLibrary();\n\n    // 使用\n    hello.printGreeting();\n  }\n")])])]),t("p",[a._v("在一个库上你可以多次调用 loadLibrary() 函数。 但是该库只是载入一次。")]),a._v(" "),t("h3",{attrs:{id:"异步支持"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#异步支持"}},[a._v("#")]),a._v(" 异步支持")]),a._v(" "),t("p",[a._v("Dart 有一些语言特性来支持 异步编程。 最常见的特性是 "),t("code",[a._v("async")]),a._v(" 方法和 "),t("code",[a._v("await")]),a._v(" 表达式。")]),a._v(" "),t("p",[a._v("简单地说，"),t("code",[a._v("Future")]),a._v("将返回一个值，而"),t("code",[a._v("Stream")]),a._v("将返回多次值。所以"),t("code",[a._v("Steam")]),a._v("使用"),t("code",[a._v("await for")])]),a._v(" "),t("p",[a._v("Future，基本上等于JS的Promise")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("  checkVersion() async {\n    var version = await lookUpVersion();\n    if (version == expectedVersion) {\n      // ...\n    } else {\n      // ...\n    }\n  }\n")])])]),t("p",[a._v("当然，Future有类似于 Promise.all([])的方法，")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("  //等待所有 Future 执行完成\n\n  Future.wait([deleteDone, copyDone, checksumDone])\n    .then((List values) {\n      print('Done with all the long steps');\n    });\n")])])]),t("p",[a._v("Stream。"),t("code",[a._v("await for")]),a._v("会在数据返回完毕后结束，所以别在无尽的数据流（比如DOM事件）中使用"),t("code",[a._v("await for")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("  initData async {\n    await for (var request in requestServer) {\n      handleRequest(request);\n    }\n  }\n")])])]),t("p",[a._v("使用 "),t("code",[a._v("break")]),a._v(" 或者 "),t("code",[a._v("return")]),a._v(" 语句可以 停止接收 "),t("code",[a._v("stream")]),a._v(" 的数据， 这样就跳出了 "),t("code",[a._v("for")]),a._v(" 循环并且 从 "),t("code",[a._v("stream")]),a._v(" 上取消注册了。")]),a._v(" "),t("h3",{attrs:{id:"元数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#元数据"}},[a._v("#")]),a._v(" 元数据")]),a._v(" "),t("p",[a._v("元数据，即注解，比如："),t("code",[a._v("@override")])]),a._v(" "),t("p",[a._v("自定义元数据")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("  library todo;\n\n  class todo {\n    final String who;\n    final String what;\n\n    const todo(this.who, this.what);\n  }\n\n  // 使用\n\n  import 'todo.dart';\n\n  @todo('seth', 'make this do something')\n  void doSomething() {\n    print('do something');\n  }\n")])])]),t("p",[a._v("不过，Flutter似乎"),t("strong",[a._v("不支持")]),t("code",[a._v("反射")]),a._v("。")])])}),[],!1,null,null,null);e.default=n.exports}}]);